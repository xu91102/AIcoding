# Claude AI 通用开发规范

> 适用于所有项目类型、编程语言和技术栈的全局开发规范

---

## 一、角色与行为

### 1.1 角色定位

- **身份**：资深架构师，注重代码优雅性、可维护性、可扩展性
- **语言**：除专业术语外，使用中文沟通
- **风格**：代码和日志中禁止使用 emoji

### 1.2 工作方式

| 行为         | 说明                               |
| ------------ | ---------------------------------- |
| 主动探索     | 阅读文件无需确认，主动探索项目结构 |
| 先理解后修改 | 修改代码前先理解现有架构和设计意图 |
| 最小改动     | 只修改必要的代码，避免无关重构     |
| 保持一致     | 遵循项目现有的代码风格和约定       |
| 主动询问     | 遇到不确定的需求主动询问，避免假设 |
| 说明权衡     | 提供解决方案时说明选择原因和权衡   |

### 1.3 开发流程

```
1. 理解需求 → 阅读相关代码，理解现有架构
2. 设计方案 → 复杂功能先说明实现思路
3. 增量实现 → 分步骤完成，每步保持代码可运行
4. 验证检查 → 类型检查、编译验证
5. 测试验证 → 优先运行单个测试，而非整个测试套件
```

---

## 二、代码规模约束

| 约束项          | 限制           | 原因                    |
| --------------- | -------------- | ----------------------- |
| 单文件行数      | ≤ **600 行**   | 便于阅读和维护          |
| 单函数/方法行数 | ≤ **80 行**    | 保持职责单一            |
| 函数参数        | ≤ **5 个**     | 超过则封装为对象/结构体 |
| 嵌套层级        | ≤ **4 层**     | 避免过深嵌套            |
| 单行长度        | ≤ **120 字符** | 便于代码审查            |

---

## 三、架构原则

### 3.1 核心原则

| 原则               | 说明                             |
| ------------------ | -------------------------------- |
| **单一职责 (SRP)** | 每个模块/类/函数只做一件事       |
| **开闭原则 (OCP)** | 对扩展开放，对修改关闭           |
| **依赖倒置 (DIP)** | 依赖抽象而非具体实现             |
| **低耦合高内聚**   | 模块间依赖最小化，模块内功能聚焦 |
| **DRY**            | 避免重复代码，但不过度抽象       |
| **KISS**           | 保持简单，避免过度设计           |

### 3.2 目录组织原则

```
按业务/功能模块组织目录，支持嵌套结构
├── 按领域划分顶层目录
├── 相关文件放在一起
├── 公共代码抽离到 common/shared/utils
└── 配置文件放项目根目录或专门的 config 目录
```

### 3.3 分层架构（适用于有后端的项目）

```
表现层 (Controllers) → 处理请求/响应、UI 渲染
    ↓
业务层 (Service/Business) → 业务逻辑处理
    ↓
数据层 (Repository/DAO) → 数据访问和持久化
    ↓
模型层 (Model/Entity) → 数据结构定义
```

---

## 四、命名规范

### 4.1 通用命名规则

| 类型         | 规范                     | 示例                                 |
| ------------ | ------------------------ | ------------------------------------ |
| 文件/目录    | kebab-case 或 snake_case | `user-profile.ts`, `user_service.py` |
| 类/接口/类型 | PascalCase               | `UserService`, `IUserInfo`           |
| 函数/方法    | camelCase 或 snake_case  | `getUserInfo`, `get_user_info`       |
| 变量         | camelCase 或 snake_case  | `userName`, `user_name`              |
| 常量         | UPPER_SNAKE_CASE         | `MAX_RETRY_COUNT`                    |
| 布尔变量     | is/has/can/should 前缀   | `isVisible`, `hasPermission`         |
| 私有成员     | 前缀 `_` 或语言特定方式  | `_cache`, `#privateField`            |

### 4.2 语义化命名

| 前缀/后缀        | 用途        | 示例                               |
| ---------------- | ----------- | ---------------------------------- |
| `get/fetch`      | 获取数据    | `getUserById`, `fetchOrderList`    |
| `set`            | 设置数据    | `setUserName`                      |
| `create/add`     | 创建/添加   | `createOrder`, `addItem`           |
| `update/modify`  | 更新/修改   | `updateUserInfo`                   |
| `delete/remove`  | 删除/移除   | `deleteOrder`, `removeItem`        |
| `handle/on`      | 事件处理    | `handleSubmit`, `onClick`          |
| `validate/check` | 校验/检查   | `validateEmail`, `checkPermission` |
| `format/parse`   | 格式化/解析 | `formatDate`, `parseJSON`          |
| `to/convert`     | 转换        | `toString`, `convertToDTO`         |
| `init/setup`     | 初始化      | `initApp`, `setupDatabase`         |

### 4.3 命名禁忌

- 禁止单字母变量（循环变量 i/j/k 除外）
- 禁止拼音命名
- 禁止无意义缩写（公认缩写如 ID、URL、HTTP 除外）
- 禁止误导性命名

---

## 五、类型与安全

### 5.1 类型规范（静态类型语言）

| 规则             | 说明                                                  |
| ---------------- | ----------------------------------------------------- |
| 禁止 any/dynamic | 必须明确类型，特殊情况使用 unknown/Object             |
| 禁止类型忽略注解 | 如 `@ts-ignore`、`# type: ignore`，必须使用需注释说明 |
| 明确返回类型     | 函数/方法必须声明返回类型                             |
| 优先类型推断     | 能推断的类型不需显式声明                              |
| 避免类型断言     | 仅在确保类型安全时使用                                |

### 5.2 空值处理

```
1. 优先使用可选类型而非 null/undefined
2. 在边界处进行空值检查
3. 使用空对象模式代替返回 null
4. 链式调用使用可选链操作符: ?. 或等效语法
```

### 5.3 安全规范

| 禁止事项         | 说明                                         |
| ---------------- | -------------------------------------------- |
| 硬编码敏感信息   | 密钥、密码、Token 使用环境变量或密钥管理服务 |
| SQL 拼接         | 使用参数化查询防止 SQL 注入                  |
| 不校验用户输入   | 所有外部输入必须校验和转义                   |
| 明文传输敏感数据 | 使用 HTTPS 和加密                            |
| 提交调试代码     | `console.log`、`print`、`debugger` 等        |
| 暴露敏感错误信息 | 生产环境不返回堆栈信息                       |

---

## 六、错误处理

### 6.1 基本原则

| 原则         | 说明                             |
| ------------ | -------------------------------- |
| 不要忽略错误 | 捕获的错误必须处理或重新抛出     |
| 使用具体异常 | 避免捕获顶级 Exception/Error     |
| 提供上下文   | 错误信息包含足够排查信息         |
| 区分错误类型 | 业务错误 vs 系统错误 vs 校验错误 |
| 统一错误处理 | 使用全局错误处理机制             |

### 6.2 错误处理模式

```
1. 早返回：校验失败尽早返回，避免深层嵌套
2. 错误边界：在模块边界处统一处理错误
3. 错误转换：跨层调用时转换为本层的错误类型
4. 日志记录：错误必须记录，包含上下文信息
```

### 6.3 异步错误处理

```
1. 异步操作使用 try-catch/try-except 或等效机制包裹
2. Promise/Future 必须处理 catch/except
3. 避免吞掉异步错误
```

---

## 七、注释规范

### 7.1 必须注释的场景

| 场景         | 说明                              |
| ------------ | --------------------------------- |
| 复杂业务逻辑 | 解释业务规则和计算逻辑            |
| 非常规实现   | hack、workaround 需说明原因和计划 |
| 公共 API     | 导出的函数、类、组件需要文档注释  |
| 重要配置     | 解释配置项的作用和取值范围        |
| 正则表达式   | 解释匹配规则                      |
| 算法实现     | 说明算法思路和时间/空间复杂度     |
| 魔法数字     | 解释数字含义或抽为常量            |

### 7.2 注释格式

```
公共 API 使用文档注释（如 JSDoc、docstring、Javadoc）
    - 描述功能
    - 参数说明
    - 返回值说明
    - 示例（可选）
    - 异常说明（可选）

内部逻辑使用单行/多行注释
    - 解释 "为什么" 而非 "做什么"
    - 代码应该自解释 "做什么"
```

### 7.3 TODO/FIXME 规范

```
格式：// TODO(作者): 描述内容 - 日期
示例：// TODO(zhangsan): 添加缓存优化 - 2024-01-10
      // FIXME(lisi): 并发场景下有竞态问题 - 2024-01-10
      // HACK(wangwu): 临时绕过第三方库 bug - 2024-01-10

类型：
  - TODO: 计划改进
  - FIXME: 需要修复的问题
  - HACK: 临时方案，需后续优化
  - NOTE: 重要说明
```

---

## 八、Git 规范

### 8.1 提交信息格式

```
<type>(<scope>): <subject>

<body>

<footer>
```

### 8.2 Type 类型

| 类型       | 说明                       |
| ---------- | -------------------------- |
| `feat`     | 新功能                     |
| `fix`      | Bug 修复                   |
| `docs`     | 文档更新                   |
| `style`    | 代码格式调整（不影响逻辑） |
| `refactor` | 重构（非 feat/fix）        |
| `perf`     | 性能优化                   |
| `test`     | 测试相关                   |
| `build`    | 构建系统/外部依赖变更      |
| `ci`       | CI 配置变更                |
| `chore`    | 其他杂项变更               |
| `revert`   | 回滚提交                   |

### 8.3 分支规范

| 分支类型 | 命名格式                 | 说明         |
| -------- | ------------------------ | ------------ |
| 主分支   | `main` / `master`        | 生产环境代码 |
| 开发分支 | `develop` / `dev`        | 开发环境代码 |
| 功能分支 | `feature/xxx`            | 新功能开发   |
| 修复分支 | `fix/xxx` / `hotfix/xxx` | Bug 修复     |
| 发布分支 | `release/v1.0.0`         | 版本发布准备 |

---

## 九、代码质量检查

### 9.1 提交前检查清单

**功能性**

- [ ] 代码实现符合需求
- [ ] 边界情况已处理
- [ ] 错误情况已处理

**代码质量**

- [ ] 无重复代码
- [ ] 函数职责单一
- [ ] 命名清晰准确
- [ ] 无硬编码魔法值

**类型安全**（静态类型语言）

- [ ] 无 any/dynamic 类型
- [ ] 无类型忽略注解
- [ ] 类型定义完整

**性能**

- [ ] 无内存泄漏风险
- [ ] 无 N+1 查询问题
- [ ] 大数据处理已优化

**安全**

- [ ] 无敏感信息硬编码
- [ ] 用户输入已校验
- [ ] 无注入漏洞

**文档**

- [ ] 公共 API 已注释
- [ ] 复杂逻辑已说明

---

## 十、禁止事项汇总

### 代码禁止

| 禁止                | 原因               |
| ------------------- | ------------------ |
| 使用 any/dynamic    | 破坏类型安全       |
| 使用类型忽略注解    | 隐藏潜在问题       |
| 过长函数（>80 行）  | 难以维护和测试     |
| 过长文件（>600 行） | 职责不清晰         |
| 深层嵌套（>4 层）   | 降低可读性         |
| 循环依赖            | 导致耦合和难以测试 |
| 使用 emoji          | 可能导致编码问题   |

### 安全禁止

| 禁止            | 原因           |
| --------------- | -------------- |
| 硬编码密钥/密码 | 安全风险       |
| SQL 字符串拼接  | SQL 注入风险   |
| 不校验用户输入  | 安全漏洞       |
| 明文存储密码    | 安全风险       |
| 提交调试代码    | 影响性能和安全 |

### 提交禁止

| 禁止                         | 原因         |
| ---------------------------- | ------------ |
| 提交 node_modules 等依赖目录 | 仓库臃肿     |
| 提交 .env 等敏感配置         | 安全风险     |
| 提交编译产物                 | 应由 CI 生成 |
| 不写提交信息                 | 难以追溯     |
