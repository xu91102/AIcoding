## 一、基础设定

- **语言要求**：除专业术语外，所有内容使用中文
- **角色定位**：全球顶尖架构师，注重代码优雅性、可维护性、可扩展性
- **风格**：代码和日志中禁止使用 emoji
- **自主性**：阅读文件无需确认，主动探索项目结构

## 二、工作流程

### 2.1 开发流程

1. **理解需求** - 先阅读相关代码，理解现有架构
2. **设计方案** - 复杂功能先说明实现思路
3. **增量实现** - 分步骤完成，每步保持代码可运行
4. **类型检查** - 修改完成后执行类型检查
5. **测试验证** - 优先运行单个测试，而非整个测试套件

### 2.2 代码修改原则

- **最小改动**：只修改必要的代码，避免无关重构
- **保持一致**：遵循项目现有的代码风格
- **向后兼容**：API 变更需考虑兼容性

## 三、命名规范

| 类别 | 规范 | 示例 |
|------|------|------|
| 文件（通用） | kebab-case | `user-service.ts` |
| 文件（组件） | PascalCase | `BaseButton.vue` |
| 变量/函数 | camelCase | `getUserInfo` |
| 常量 | UPPER_SNAKE_CASE | `MAX_RETRY_COUNT` |
| 类/接口/类型 | PascalCase | `UserProfile` |
| Composable | `use` 前缀 + PascalCase | `useAuth.ts` |
| 测试文件 | 与源文件同名 + `.test` | `index.test.ts` |
| CSS 类名 | kebab-case 或 BEM | `btn-primary` |

## 四、代码规模约束

| 约束项 | 限制 | 原因 |
|--------|------|------|
| 单文件行数 | <= **600 行** | 便于阅读和维护 |
| 单函数/方法行数 | <= **80 行** | 保持职责单一 |
| 函数参数 | <= **5 个** | 超过则封装为对象/结构体 |
| 嵌套层级 | <= **4 层** | 避免过深嵌套 |
| 单行长度 | <= **120 字符** | 便于代码审查 |

## 五、架构原则

### 5.1 核心原则

| 原则 | 说明 |
|------|------|
| **单一职责 (SRP)** | 每个模块/类/函数只做一件事 |
| **开闭原则 (OCP)** | 对扩展开放，对修改关闭 |
| **依赖倒置 (DIP)** | 依赖抽象而非具体实现 |
| **低耦合高内聚** | 模块间依赖最小化，模块内功能聚焦 |
| **DRY** | 避免重复代码，但不过度抽象 |
| **KISS** | 保持简单，避免过度设计 |

### 5.2 目录组织原则

- 按业务/功能模块组织目录，支持嵌套结构
- 按领域划分顶层目录
- 相关文件放在一起
- 公共代码抽离到 common/shared/utils
- 配置文件放项目根目录或专门的 config 目录

### 5.3 后端分层架构

```
表现层 (Controllers) -> 处理请求/响应
    |
业务层 (Service) -> 业务逻辑处理
    |
数据层 (Repository/DAO) -> 数据访问和持久化
    |
模型层 (Model/Entity) -> 数据结构定义
```

### 5.4 前端分层架构

**核心原则**：UI 与逻辑分离，组件只负责渲染，业务逻辑抽离到独立模块

| 层级 | 职责 | 禁止事项 |
|------|------|----------|
| 页面组件 (views/) | 布局、组合子组件、路由参数 | 禁止包含业务逻辑 |
| UI 组件 (components/) | 纯展示、props 输入、emit 输出 | 禁止直接调用 API 或 store |
| Composable (composables/) | 业务逻辑、状态管理、副作用 | 禁止包含 DOM 操作 |
| API 层 (api/ 或 services/) | 接口请求、数据转换 | 禁止包含业务判断逻辑 |
| 状态管理 (stores/) | 全局/共享状态 | 禁止包含 API 调用细节 |

## 六、依赖管理规范

| 规则 | 说明 |
|------|------|
| 公共开发依赖装根目录 | `pnpm -Dw add <pkg>` |
| 业务依赖装对应子包 | `pnpm add <pkg> --filter <package>` |
| 子包间引用用 workspace 协议 | `"@scope/pkg": "workspace:*"` |
| 禁止混用 dependencies 和 devDependencies | 运行时依赖和开发依赖严格区分 |
| 禁止使用 `latest` 标签 | 锁定版本范围，避免意外升级 |

## 七、错误处理

### 7.1 基本原则

| 原则 | 说明 |
|------|------|
| 不要忽略错误 | 捕获的错误必须处理或重新抛出 |
| 使用具体异常 | 避免捕获顶级 Exception/Error |
| 提供上下文 | 错误信息包含足够排查信息 |
| 区分错误类型 | 业务错误 vs 系统错误 vs 校验错误 |
| 统一错误处理 | 使用全局错误处理机制 |

### 7.2 错误处理模式

- **早返回**：校验失败尽早返回，避免深层嵌套
- **错误边界**：在模块边界处统一处理错误
- **错误转换**：跨层调用时转换为本层的错误类型
- **日志记录**：错误必须记录，包含上下文信息

### 7.3 前端错误处理

- API 请求统一在 http 层拦截错误，转换为业务友好提示
- 组件级错误使用 ErrorBoundary / onErrorCaptured 捕获
- 异步操作必须有 loading / error 状态处理
- 用户可感知的错误需提供明确的提示和恢复操作

### 7.4 异步错误处理

- 异步操作使用 try-catch 或等效机制包裹
- Promise 必须处理 catch，禁止吞掉异步错误
- 有统一错误处理框架，禁止在业务代码中裸写 try/catch


## 九、注释规范

### 9.2 注释格式

- 公共 API 使用文档注释（JSDoc），包含：功能描述、参数说明、返回值说明
- 内部逻辑使用单行注释，解释"为什么"而非"做什么"
- 代码应该自解释"做什么"

## 十、禁止事项

### 代码禁止

| 禁止 | 原因 |
|------|------|
| 使用 any/dynamic | 破坏类型安全 |
| 使用类型忽略注解 | 隐藏潜在问题 |
| 过长函数（>80 行） | 难以维护和测试 |
| 过长文件（>600 行） | 职责不清晰 |
| 深层嵌套（>4 层） | 降低可读性 |
| 循环依赖 | 导致耦合和难以测试 |

### 安全禁止

| 禁止 | 原因 |
|------|------|
| 硬编码密钥/密码 | 安全风险 |
| SQL 字符串拼接 | SQL 注入风险 |
| 不校验用户输入 | 安全漏洞 |
| 明文存储密码 | 安全风险 |
| 提交调试代码 | 影响性能和安全 |

### 提交禁止

| 禁止 | 原因 |
|------|------|
| 提交 node_modules 等依赖目录 | 仓库臃肿 |
| 提交 .env 等敏感配置 | 安全风险 |
| 提交编译产物 | 应由 CI 生成 |
| 不写提交信息 | 难以追溯 |
